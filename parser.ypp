
%{
	#include <iostream>
	#include <sstream>
	#include <stdlib.h>
	#include "parser.hpp"
	#include "output.hpp"
	#include "bp.hpp"
	#include "parser.tab.hpp"
	
	using namespace output;
	using std::cout;
	using std::endl;
	
	extern int yylineno;
	int yylex();
	void yyerror(char const*);
	
	SymbolTable* table = NULL;
	RegPool* regPool;
	CodeBuffer &codeBuffer = CodeBuffer::instance();
	
	string genLabel();
	int emit(string code);
	vector<int> makelist(int i);
	void backpatch(const std::vector<int>& address_list, const std::string &loc);
	vector<int> emitWithPatch(string code);
	string loadi(int reg, int i);
	string load(int reg, int offset);
	vector<int> merge(const vector<int> &l1,const vector<int> &l2);
	string store(int reg, int offset);
	void pop(int reg);
	void rpop(int reg);
	void push(int reg);
	void rpush(int reg);
	void emitPrint();
	void emitPrinti();
	void storeRegs();
	void loadRegs();
	
%}

%define api.value.type {union YYSTYPE}

%type <str> Program
%type <str> Funcs
%type <str> FuncDecl
%type <str> Structs
%type <str> StructsDecl
%type <str> RetType
%type <str> Formals
%type <str> FormalsList
%type <str> FormalDecl
%type <structMembers> StructMemList
%type <str> StructMem
%type <node> Statements
%type <node> Statement
%type <str> If
%type <var> Call
%type <funcParams> CallParams
%type <str> ExpList
%type <str> VarDecl
%type <str> Type
%type <str> StructType
%type <var> Exp

%token <str> VOID
%token <str> INT
%token <str> BYTE
%token <str> B
%token <str> BOOL
%token <str> STRUCT
%token <str> TRUE
%token <str> FALSE
%token <str> RETURN
%token <str> IF
%nonassoc <str> "then"
%nonassoc <str> ELSE
%token <str> WHILE
%token <str> BREAK
%token <str> CONTINUE
%token <str> SC
%token <str> COMMA
%token <str> LBRACE
%token <str> RBRACE
%token <str> ID
%token <num> NUM
%token <str> STRING
%token <str> EF
%right <str> ASSIGN
%left <str> OR
%left <str> AND
%right <str> EQ
%nonassoc <str> REL
%left  <str> ADD
%left  <str> MUL
%right <str> NOT
%left <str> LPAREN
%left <str> RPAREN
%left <str> PERIOD

%%

/* Program -> Structs Funcs */
/****************************************************************************/
Program : {
		/********************************************************************/
			string baseTypes[] = { "int","bool","byte","string" };
			table = new SymbolTable(baseTypes, 4, "block");
			regPool = new RegPool();
			string printParamNames[] = { "_noName" };
			string printParamTypes[] = { "string" };
			table->addFunc(
				"print",
				"void",
				printParamNames,
				printParamTypes,
				1
			);
			emitPrint();
			emit("");
			string printiParamNames[] = { "_noName" };
			string printiParamTypes[] = { "int" };
			table->addFunc(
				"printi",
				"void",
				printiParamNames,
				printiParamTypes,
				1
			);
			emitPrinti();
			emit("");
		/********************************************************************/
		} Structs { } Funcs {
		/********************************************************************/
			try {
				if ((table->findFunc("main").getRetType() != "void") ||
					(table->findFunc("main").size() != 0)){
						throw FunctionNotFoundException();
				}
			}
			catch (FunctionNotFoundException e) {
				// Missing main function
				errorMainMissing();
				exit(0);
			}
			try {
				table->removeScope();
			}
			catch (RemovedBaseScopeException e) {
				// as it should
			}
		/********************************************************************/
		} EF {
		/********************************************************************/
			return 0;
		}
/****************************************************************************/
;

/* Funcs -> FuncDecl Funcs */
/****************************************************************************/
Funcs	: FuncDecl { } Funcs { }
/****************************************************************************/


/* Funcs -> eps */
/****************************************************************************/
		| /*epsilon*/ { }
/****************************************************************************/
;

/* Funcs -> RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE */
/****************************************************************************/
FuncDecl : RetType ID {
		/********************************************************************/
			if (table->isNameUsed(*($<str>ID))){
				// Redeclaration of function
				errorDef(yylineno,*($<str>ID));
				exit(0);
			}
		/********************************************************************/
		} LPAREN Formals RPAREN {
		/********************************************************************/
			if ($<funcParams>Formals){
				table->addFunc(
					*($<str>ID),
					*($<str>RetType),
					*($<funcParams>Formals)
				);
			}
			else {
				table->addFunc(*($<str>ID),*($<str>RetType));
			}
		/********************************************************************/
		} LBRACE {
		/********************************************************************/
			if ($<funcParams>Formals){
				table->addScope(
					($<funcParams>Formals)->getParamsNames(),
					($<funcParams>Formals)->getParamsTypes(),
					("function"),
					(*($<str>RetType)));
				delete ($<funcParams>Formals);
			}
			else {
				table->addScope("function",*($<str>RetType));
			}
			emit("");
			emit("#function: " + *($<str>ID));
			emit(*($<str>ID) + ":");
			push(30); //backup $fp
			emit("addi $fp, $sp, 4"); //link new fp
		/********************************************************************/
		} Statements { } RBRACE {
		/********************************************************************/
			stringstream code;
			code << *($<str>ID) << "_end";
			backpatch($<node>Statements->nextlist(),code.str());
			backpatch($<node>Statements->returnlist(),code.str());
			code << ":";
			emit(code.str());
			emit("addi $sp, $fp, -4");
			pop(30);
			emit("jr $ra");
			try{
				table->removeScope();
			}
			catch (NoScopesException e){
				throw NoScopesException();
			}
			delete ($<str>RetType);
			delete ($<str>ID);
		}
/****************************************************************************/
;

/* Structs -> StructsDecl Structs */
/****************************************************************************/
Structs : StructsDecl Structs { }
/****************************************************************************/


/* Structs -> eps */
/****************************************************************************/
		| /*epsilon*/ { }
/****************************************************************************/
;

/* StructsDecl -> STRUCT ID LBRACE StructMemList RBRACE SC */
/****************************************************************************/
StructsDecl : STRUCT ID {
		/********************************************************************/
			if (table->isNameUsed(*($<str>ID))){
					// Redeclaration of struct
					errorDef(yylineno,*($<str>ID));
					exit(0);
				}
		/********************************************************************/
		} LBRACE StructMemList RBRACE SC {
		/********************************************************************/
			table->addStruct(*($<str>ID),*($<structMembers>StructMemList));
			delete ($<structMembers>StructMemList);
			delete ($<str>ID);
		}
/****************************************************************************/
;

/* RetType -> Type */
/****************************************************************************/
RetType : Type {
			$<str>RetType = $<str>Type;
		}
/****************************************************************************/


/* RetType -> VOID */
/****************************************************************************/
		| VOID {
			$<str>RetType = $<str>VOID;
		}
/****************************************************************************/
;

/* Formals -> FormalsList */
/****************************************************************************/
Formals : FormalsList {
			$<funcParams>Formals = $<funcParams>FormalsList;
		}
/****************************************************************************/


/* Formals -> eps */
/****************************************************************************/
		| /*epsilon*/ {
			$<funcParams>Formals = NULL;
		}
/****************************************************************************/
;

/* FormalsList -> FormalDecl */
/****************************************************************************/
FormalsList[result] : FormalDecl {
			try{
				FuncParams* params = new FuncParams();
				params->addParam(*($<var>FormalDecl));
				$<funcParams>result = params;
				delete ($<var>FormalDecl);
			}
			catch (NameAlreadyExistsException e){
				// Redeclaration of function parameter
				errorDef(yylineno,($<var>FormalDecl)->getName());
				exit(0);
			}
			
		}
/****************************************************************************/


/* FormalsList -> FormalsList COMMA FormalDecl */
/****************************************************************************/
		| FormalsList[right] COMMA FormalDecl {
			try {
				($<funcParams>right)->addParam(*($<var>FormalDecl));
				$<funcParams>result = $<funcParams>right;
				delete ($<var>FormalDecl);
			}
			catch (NameAlreadyExistsException e){
				// Redeclaration of function parameter
				errorDef(yylineno,($<var>FormalDecl)->getName());
				exit(0);
			}		
		}
/****************************************************************************/
;

/* FormalDecl -> Type ID */
/****************************************************************************/
FormalDecl : Type ID {
			$<var>FormalDecl = new Var(*($<str>ID),*($<str>Type));
			delete ($<str>ID);
			delete ($<str>Type);
		}
/****************************************************************************/


/* FormalDecl -> StructType ID */
/****************************************************************************/
		| StructType { 
		/********************************************************************/
			if (!table->isTypeExists(*($<str>StructType))){
				// Declaration of function parameter of undefined struct type
				errorUndefStruct(yylineno,*($<str>StructType));
				exit(0);
			}
		/********************************************************************/
		} ID {
		/********************************************************************/
			$<var>FormalDecl = new Var(*($<str>ID),*($<str>StructType));
			delete ($<str>ID);
			delete ($<str>StructType);
		}
/****************************************************************************/
;

/* StructMemList -> StructMem */
/****************************************************************************/
StructMemList[result] : StructMem {
			try {
				StructMembers* members = new StructMembers();
				members->addMember(*($<var>StructMem));
				$<structMembers>result = members;
				delete ($<var>StructMem);
			}
			catch (NameAlreadyExistsException e){
				// Redeclaration of struct members
				errorDef(yylineno,($<var>StructMem)->getName());
				exit(0);
			}
		}
/****************************************************************************/


/* StructMemList -> StructMemList StructMem */
/****************************************************************************/
		| StructMemList[right] StructMem  {
			try {
				($<structMembers>right)->addMember(*($<var>StructMem));
				$<structMembers>result = $<structMembers>right;
				delete ($<var>StructMem);
			}
			catch (NameAlreadyExistsException e){
				// Redeclaration of struct members
				errorDef(yylineno,($<var>StructMem)->getName());
				exit(0);
			}
		}
/****************************************************************************/
;

/* StructMem -> Type ID SC */
/****************************************************************************/
StructMem : Type ID SC {
			$<var>StructMem = new Var(*($<str>ID),*($<str>Type));
			delete ($<str>ID);
			delete ($<str>Type);
		}
/****************************************************************************/
;

/* Statements -> Statement */
/****************************************************************************/
Statements[result] : Statement[right] { 
			$<node>result = new Node();			
			$<node>result->nextlist() = $<node>right->nextlist();
			$<node>result->continuelist() = $<node>right->continuelist();
			$<node>result->breaklist() = $<node>right->breaklist();
			$<node>result->falselist() = $<node>right->falselist();
			$<node>result->returnlist() = $<node>right->returnlist();
			$<node>result->truelist() = $<node>right->truelist();
			delete($<node>right);
		}
/****************************************************************************/


/* Statements -> Statements Statement */
/****************************************************************************/
		| Statements[left] {
			if (merge(
				$<node>left->nextlist(),
				$<node>left->falselist()).size() != 0) {
					string nextLabel = genLabel();
					backpatch($<node>left->nextlist(), nextLabel);
					backpatch($<node>left->falselist(), nextLabel);
				}
		} Statement[right] { 
			$<node>result = new Node();			
			$<node>result->nextlist() = $<node>right->nextlist();
			$<node>result->falselist() = $<node>right->falselist();
			$<node>result->continuelist() = merge(
				$<node>right->continuelist(),
				$<node>left->continuelist());
			$<node>result->breaklist() = merge(
				$<node>right->breaklist(),
				$<node>left->breaklist());
			$<node>result->returnlist() = merge(
				$<node>right->returnlist(),
				$<node>left->returnlist());
			$<node>result->truelist() = merge(
				$<node>right->truelist(),
				$<node>left->truelist());
			delete($<node>left);
			delete($<node>right);
		}
/****************************************************************************/
;

/* Statement -> LBRACE Statements RBRACE */
/****************************************************************************/
Statement[result] : LBRACE { 
		/********************************************************************/
			const string& initiator = table->getScopeInitiator();
			const string& retType = table->getScopeRetType();
			if (initiator == "while"){
				table->addScope("while",retType);
			}
			else {
				table->addScope(initiator,retType);
			}
		/********************************************************************/
		} Statements[right] RBRACE {
		/********************************************************************/
			table->removeScope();
			$<node>result = new Node();			
			$<node>result->nextlist() = $<node>right->nextlist();
			$<node>result->falselist() = $<node>right->falselist();
			$<node>result->returnlist() = $<node>right->returnlist();
			$<node>result->truelist() = $<node>right->truelist();
			$<node>result->continuelist() = $<node>right->continuelist();
			$<node>result->breaklist() = $<node>right->breaklist();
			delete($<node>right);
		}
/****************************************************************************/


/* Statement -> VarDecl SC */
/****************************************************************************/
		| VarDecl SC { 
			$<node>result = new Node();
		}
/****************************************************************************/


/* Statement -> StructsDecl */
/****************************************************************************/
		| StructsDecl { 
			$<node>result = new Node();
		}
/****************************************************************************/


/* Statement -> VarDecl ASSIGN Exp SC */
/****************************************************************************/
		| VarDecl[left] ASSIGN Exp[right] SC {
			const string& leftType = ($<var>left)->getType();
			const string& leftName = ($<var>left)->getName();
			const int leftPlace = table->findVar(leftName).getPlace();
			const string& rightType = ($<var>right)->getType();
			const string& rightName = ($<var>right)->getName();
			const int rightPlace = $<var>right->getPlace();
			if ((leftType != rightType)&&
				(leftType != "int" || rightType != "byte")){
				// Mismatch of assing operation
				errorMismatch(yylineno);
				exit(0);
			}
			
			try {
				const StructNode& structNode = table->findStruct(rightType);				
				for ( int i = 0 ; i < structNode.size() ; i++ ) {
					$<var>right->allocReg(regPool->allocateReg());
					int structMemPlace = structNode[i].getPlace();
					emit(load($<var>right->getReg(), rightPlace + structMemPlace ));
					emit(store($<var>right->getReg(),leftPlace + structMemPlace ));					
					regPool->freeReg($<var>right->getReg());
					$<var>right->freeReg();
				}
			}
			catch (StructNotFoundException e){
				if ( rightType == "bool") {
					$<var>right->allocReg(regPool->allocateReg());
					string falseLabel = genLabel();
					emit(loadi($<var>right->getReg(),0));
					vector<int> tempVector = makelist(emit("j "));
					string trueLabel = genLabel();
					emit(loadi($<var>right->getReg(),1));
					string nextLabel = genLabel();
					backpatch($<var>right->falselist(), falseLabel);
					backpatch($<var>right->truelist(), trueLabel);
					backpatch(tempVector, nextLabel);
				}
				emit(store($<var>right->getReg(),leftPlace));
				regPool->freeReg($<var>right->getReg());
				$<var>right->freeReg();
			}
			$<node>result = new Node();
			if (rightName == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Statement -> ID ASSIGN Exp SC */
/****************************************************************************/
		| ID[left] ASSIGN { 
		/********************************************************************/
		try {
				table->findVar(*($<str>left));
			}
			catch (VariableNotFoundException e){
				// Using undefined variable
				errorUndef(yylineno,*($<str>left));
				exit(0);
			}
		/********************************************************************/
		} Exp[right] SC { 
		/********************************************************************/
			const string& rightType = ($<var>right)->getType();
			const string& rightName = ($<var>right)->getName();
			const int rightPlace = $<var>right->getPlace();
			const string& leftType = (
				table->findVar(*($<str>left))).getType();
			const string& leftName = (
				table->findVar(*($<str>left))).getName();
			const int leftPlace = table->findVar(*($<str>left)).getPlace();
			if ((leftType != rightType)&&
				(leftType != "int" || rightType != "byte")){
				// Mismatch of assing operation
				errorMismatch(yylineno);
				exit(0);
			}
			try {
				const StructNode& structNode = table->findStruct(rightType);				
				for ( int i = 0 ; i < structNode.size() ; i++ ) {
					$<var>right->allocReg(regPool->allocateReg());
					int structMemPlace = structNode[i].getPlace();
					emit(load($<var>right->getReg(), rightPlace + structMemPlace ));
					emit(store($<var>right->getReg(),leftPlace + structMemPlace ));					
					regPool->freeReg($<var>right->getReg());
					$<var>right->freeReg();
				}
			}
			catch (StructNotFoundException e){
				if ( rightType == "bool") {
					$<var>right->allocReg(regPool->allocateReg());
					string falseLabel = genLabel();
					emit(loadi($<var>right->getReg(),0));
					vector<int> tempVector = makelist(emit("j "));
					string trueLabel = genLabel();
					emit(loadi($<var>right->getReg(),1));
					string nextLabel = genLabel();
					backpatch($<var>right->falselist(), falseLabel);
					backpatch($<var>right->truelist(), trueLabel);
					backpatch(tempVector, nextLabel);
				}
				emit(store($<var>right->getReg(),leftPlace));
				regPool->freeReg($<var>right->getReg());
				$<var>right->freeReg();
			}
			$<node>result = new Node();
			if (rightName == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Statement -> ID PERIOD ID ASSIGN Exp SC */
/****************************************************************************/
		| ID[left] PERIOD { 
		/********************************************************************/
			try{
				const string& structName =
					table->findVar(*($<str>left)).getType();
				table->findStruct(structName);
			}
			catch (VariableNotFoundException e){
				// Using undefined struct
				errorUndef(yylineno,*($<str>left));
				exit(0);
			}
			catch (StructNotFoundException e){
				// Using undefined struct
				errorUndef(yylineno,*($<str>left));
				exit(0);
			}
		/********************************************************************/
		} ID[mid] { 
		/********************************************************************/
			try{
				const string& structName =
					table->findVar(*($<str>left)).getType();
				table->findStruct(structName).find(*($<str>mid));
			}
			catch (VariableNotFoundException e){
				// Using undefined struct member
				errorUndefStructMember(yylineno,*($<str>left));
				exit(0);
			}
		/********************************************************************/
		} ASSIGN Exp[right] SC {
		/********************************************************************/
			const string& rightType = ($<var>right)->getType();
			const string& rightName = ($<var>right)->getName();
			const string& structName =
					table->findVar(*($<str>left)).getType();
			const string& leftType = 
				table->findStruct(structName).find(*($<str>mid)).getType();
			if ((leftType != rightType)&&
				(leftType != "int" || rightType != "byte")){
				// Mismatch of assing operation
				errorMismatch(yylineno);
				exit(0);
			}
			
			if ( $<var>right->getType() == "bool") {
				$<var>right->allocReg(regPool->allocateReg());
				string falseLabel = genLabel();
				emit(loadi($<var>right->getReg(),0));
				vector<int> tempVector = makelist(emit("j "));
				string trueLabel = genLabel();
				emit(loadi($<var>right->getReg(),1));
				string nextLabel = genLabel();
				backpatch($<var>right->falselist(), falseLabel);
				backpatch($<var>right->truelist(), trueLabel);
				backpatch(tempVector, nextLabel);
			}
			const StructNode& structNode = table->findStruct(structName);				
			emit(store($<var>right->getReg(), 
				$<var>right->getPlace() + (structNode.find(*($<str>mid))).getPlace() ));
			regPool->freeReg($<var>right->getReg());
			$<var>right->freeReg();
			$<node>result = new Node();
			if (rightName == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Statement -> Call SC */
/****************************************************************************/
		| Call SC {
			delete ($<var>Call);
			$<node>result = new Node();
		}
/****************************************************************************/


/* Statement -> RETURN SC */
/****************************************************************************/
		| RETURN SC {
			const string& leftType = table->getScopeRetType();
			if (leftType != "void"){
				// Mismatch of return type (non-void)
				errorMismatch(yylineno);
				exit(0);
			}
			$<node>result = new Node();
			$<node>result->returnlist() = emitWithPatch("j ");
		}
/****************************************************************************/


/* Statement -> RETURN Exp SC */
/****************************************************************************/
		| RETURN Exp[right] SC {
			const string& leftType = table->getScopeRetType();
			const string& rightType = ($<var>right)->getType();
			const string& rightName = ($<var>right)->getName();
			if ((leftType != rightType)&&
				(leftType != "int" || rightType != "byte")){
				// Mismatch of return type
				errorMismatch(yylineno);
				exit(0);
			}
			if ( $<var>right->getType() == "bool") {
				$<var>right->allocReg(regPool->allocateReg());
				string falseLabel = genLabel();
				emit(loadi($<var>right->getReg(),0));
				vector<int> tempVector = makelist(emit("j "));
				string trueLabel = genLabel();
				emit(loadi($<var>right->getReg(),1));
				string nextLabel = genLabel();
				backpatch($<var>right->falselist(), falseLabel);
				backpatch($<var>right->truelist(), trueLabel);
				backpatch(tempVector, nextLabel);
			}
			stringstream code;
			code << "move $v0, $" << $<var>right->getReg();
			emit(code.str());
			regPool->freeReg($<var>right->getReg());
			$<var>right->freeReg();
			$<node>result = new Node();
			$<node>result->returnlist() = emitWithPatch("j ");
			if (rightName == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Statement -> If */
/****************************************************************************/
		| If %prec "then"{
			$<node>result = $<node>If;
			$<node>result->nextlist() = merge(
				$<node>If->falselist(),
				$<node>If->nextlist());		
			$<node>result->falselist().clear();
		}
/****************************************************************************/


/* Statement -> If ELSE Statement */
/****************************************************************************/
		| If[left] ELSE {
			if (table->getScopeInitiator() != "while") {
				table->addScope("else", table->getScopeRetType());
			}
			else {
				table->addScope("while", table->getScopeRetType());
			}
			backpatch($<node>left->falselist(),genLabel());			
		/********************************************************************/
		} Statement[right] {
		/********************************************************************/
			table->removeScope();
			$<node>result = new Node();
			$<node>result->breaklist() = merge(
				$<node>right->breaklist(),
				$<node>left->breaklist());
			$<node>result->returnlist() = merge(
				$<node>right->returnlist(),
				$<node>left->returnlist());
			$<node>result->nextlist() = merge(
				$<node>right->nextlist(),
				$<node>left->nextlist());
			$<node>result->continuelist() = merge(
				$<node>right->continuelist(),
				$<node>left->continuelist());
			delete($<node>left);
			delete($<node>right);
		}
/****************************************************************************/


/* Statement -> WHILE LPAREN Exp RPAREN Statement */
/****************************************************************************/
		| WHILE LPAREN {
			$<str>$ = new string(genLabel());			
		} Exp { 
		/********************************************************************/
			if (($<var>Exp)->getType() != "bool"){
				// Mismatch of while condition type
				errorMismatch(yylineno);
				exit(0);
			}
		/********************************************************************/
		} RPAREN {
		/********************************************************************/
			table->addScope("while", table->getScopeRetType());
			backpatch($<var>Exp->truelist(),genLabel());
		/********************************************************************/
		} Statement[right] {
		/********************************************************************/
			table->removeScope();
			$<node>result = new Node();
			backpatch($<node>right->continuelist(),*($<str>3));
			backpatch($<node>right->nextlist(),*($<str>3));
			$<node>result->returnlist() = $<node>right->returnlist();
			$<node>result->nextlist() = merge(
				$<var>Exp->falselist(),
				$<node>right->breaklist());
			stringstream code;
			code << "j " << *($<str>3);
			emit(code.str());
			if (($<var>Exp)->getName() == "__temp"){
				delete ($<var>Exp);
			}
			delete($<node>right);
			delete($<str>3);
		}
/****************************************************************************/


/* Statement -> BREAK SC */
/****************************************************************************/
		| BREAK SC {
			if (table->getScopeInitiator() != "while"){
				// Using break statment outside of while loop
				errorUnexpectedBreak(yylineno);
				exit(0);
			}
			$<node>result = new Node();
			$<node>result->breaklist() = emitWithPatch("j ");
		}
/****************************************************************************/


/* Statement -> CONTINUE SC */
/****************************************************************************/
		| CONTINUE SC {
			if (table->getScopeInitiator() != "while"){
				// Using continue statment outside of while loop
				errorUnexpectedContinue(yylineno);
				exit(0);
			}
			$<node>result = new Node();
			$<node>result->continuelist() = emitWithPatch("j ");
			
		}
/****************************************************************************/
;

/* If -> IF LPAREN Exp RPAREN Statement */
/****************************************************************************/
If[result] 		: IF LPAREN Exp { 
		/********************************************************************/
			if (($<var>Exp)->getType() != "bool"){
				// Mismatch of if condition type
				errorMismatch(yylineno);
				exit(0);
			}
			backpatch($<var>Exp->truelist(),genLabel());
		/********************************************************************/
		} RPAREN {
		/********************************************************************/
			if (table->getScopeInitiator() != "while") {
				table->addScope("if", table->getScopeRetType());
			}
			else {
				table->addScope("while", table->getScopeRetType());
			}
		/********************************************************************/
		} Statement {
		/********************************************************************/
			table->removeScope();
			$<node>result = new Node();
			$<node>result->continuelist() = $<node>Statement->continuelist();
			$<node>result->breaklist() = $<node>Statement->breaklist();
			$<node>result->falselist() = $<var>Exp->falselist();
			$<node>result->returnlist() = $<node>Statement->returnlist();
			$<node>result->nextlist() = merge(
				$<node>Statement->nextlist(),
				emitWithPatch("j "));
			if (($<var>Exp)->getName() == "__temp"){
				delete($<var>Exp);
			}
			delete($<node>Statement);
		}
/****************************************************************************/
;

/* Call -> ID LPAREN CallParams RPAREN */
/****************************************************************************/
Call[result] : ID LPAREN { 
		/********************************************************************/
			try {
				const FuncNode& func = table->findFunc(*($<str>ID));
				push(31); // backup $ra
				vector<int> usedRegs = regPool->usedRegs(); 
				for (int i = 0; i < usedRegs.size(); i++) {
					push(usedRegs[i]); 
				}
				// back up used regs
				stringstream code;
				code << "addi $sp, $sp, -" << func.memSize();
				emit(code.str()); 
			}
			catch (FunctionNotFoundException e) {
					// Calling undefined function
					errorUndefFunc(yylineno,*($<str>ID));
					exit(0);
				}
		/********************************************************************/
		} CallParams RPAREN {
		/********************************************************************/
			const FuncNode& func = table->findFunc(*($<str>ID));
			if ($<funcParams>CallParams){
				const vector<string>& givenParamTypes =
					($<funcParams>CallParams)->getParamsTypes();
				const vector<string>& paramTypes = func.getParamsTypes();	
				if (($<funcParams>CallParams)->size() != func.size()){
					// Calling function with wrong signature
					errorPrototypeMismatch(
						yylineno,*($<str>ID),
						printTypeNames(paramTypes));
					exit(0);
				}
				for (int i=0; i<func.size(); i++){
					if ((paramTypes[i] != givenParamTypes[i]) &&
						(paramTypes[i] != "int" || givenParamTypes[i] != "byte")){
						// Calling function with wrong signature
						errorPrototypeMismatch(
							yylineno,
							*($<str>ID),
							printTypeNames(paramTypes));
						exit(0);
					}
				}
				stringstream code;
				code << "addi $sp, $sp, -" << func.memSize();
				emit(code.str());
				delete ($<funcParams>CallParams);
			}
			else {
				if (func.size() != 0){
					// Calling function with wrong signature
					errorPrototypeMismatch(
						yylineno,
						*($<str>ID),
						printTypeNames(func.getParamsTypes()));
					exit(0);
				}
			}
			$<var>result = new Var("__temp",func.getRetType());
			stringstream code;
			code.str("");
			code << "jal " << func.getName(); 
			emit (code.str());
			code.str("");
			code << "addi $sp, $sp, " << func.memSize();
			emit(code.str());
			vector<int> usedRegs = regPool->usedRegs(); 
			for (int i = 0; i < usedRegs.size(); i++) {
				pop(usedRegs[usedRegs.size() - i - 1]); 
			}
			pop(31); // restore $ra
			code.str("");
			if ( func.getRetType() != "void" ) {
				$<var>result->allocReg(regPool->allocateReg());
				code << "move $" << $<var>result->getReg() << ", $v0";
				emit (code.str());
			}
			delete($<str>ID);
		}
/****************************************************************************/
;

/* CallParams -> ExpList */
/****************************************************************************/
CallParams : ExpList {
			$<funcParams>CallParams = $<funcParams>ExpList;
			// #NoEmit
		}
/****************************************************************************/


/* CallParams -> eps */
/****************************************************************************/
		| /*ellipse*/ {
			$<funcParams>CallParams = NULL;
			// #NoEmit
		}
/****************************************************************************/
;

/* ExpList -> Exp */
/****************************************************************************/
ExpList[result] : Exp {
			FuncParams* parameters = new FuncParams();
			parameters->addParam(*($<var>Exp));
			$<funcParams>result = parameters;

			try {
				const StructNode& structNode = table->findStruct($<var>Exp->getType());				
				for ( int i = 0 ; i < structNode.size() ; i++ ) {
					$<var>Exp->allocReg(regPool->allocateReg());
					emit(load($<var>Exp->getReg(), 
						$<var>Exp->getPlace() + structNode[i].getPlace() ));
					rpush($<var>Exp->getReg());
					regPool->freeReg($<var>Exp->getReg());
					$<var>Exp->freeReg();
				}
			}
			catch (StructNotFoundException e){
				if ( $<var>Exp->getType() == "bool") {
					$<var>Exp->allocReg(regPool->allocateReg());
					string falseLabel = genLabel();
					emit(loadi($<var>Exp->getReg(),0));
					vector<int> tempVector = makelist(emit("j "));
					string trueLabel = genLabel();
					emit(loadi($<var>Exp->getReg(),1));
					string nextLabel = genLabel();
					backpatch($<var>Exp->falselist(), falseLabel);
					backpatch($<var>Exp->truelist(), trueLabel);
					backpatch(tempVector, nextLabel);
				}
				rpush($<var>Exp->getReg());
				regPool->freeReg($<var>Exp->getReg());
				$<var>Exp->freeReg();
			}
			if (($<var>Exp)->getName() == "__temp"){
				delete ($<var>Exp);
			}
		}
/****************************************************************************/


/* ExpList -> ExpList COMMA Exp */
/****************************************************************************/
		| ExpList[right] COMMA Exp {
			($<funcParams>right)->addParam(*($<var>Exp));
			$<funcParams>result = $<funcParams>right;

			try {
				const StructNode& structNode = table->findStruct($<var>Exp->getType());				
				for ( int i = 0 ; i < structNode.size() ; i++ ) {
					$<var>Exp->allocReg(regPool->allocateReg());
					emit(load($<var>Exp->getReg(), 
						$<var>Exp->getPlace() + structNode[i].getPlace() ));
					rpush($<var>Exp->getReg());
					regPool->freeReg($<var>Exp->getReg());
					$<var>Exp->freeReg();
				}
			}
			catch (StructNotFoundException e){
				if ( $<var>Exp->getType() == "bool") {
					$<var>Exp->allocReg(regPool->allocateReg());
					string falseLabel = genLabel();
					emit(loadi($<var>Exp->getReg(),0));
					vector<int> tempVector = makelist(emit("j "));
					string trueLabel = genLabel();
					emit(loadi($<var>Exp->getReg(),1));
					string nextLabel = genLabel();
					backpatch($<var>Exp->falselist(), falseLabel);
					backpatch($<var>Exp->truelist(), trueLabel);
					backpatch(tempVector, nextLabel);
				}
				rpush($<var>Exp->getReg());
				regPool->freeReg($<var>Exp->getReg());
				$<var>Exp->freeReg();
			}

			if (($<var>Exp)->getName() == "__temp"){
				delete ($<var>Exp);
			}
		}
/****************************************************************************/
;

/* VarDecl -> Type ID */
/****************************************************************************/
VarDecl[result] : Type ID {
			try {
				table->addVar(*($<str>ID),*($<str>Type));
				($<var>result) = const_cast<Var*>(&(table->findVar(*($<str>ID))));
			}
			catch (NameAlreadyExistsException e){
				// Redeclaration of variable
				errorDef(yylineno,*($<str>ID));
				exit(0);
			}
			push(0);
			delete($<str>Type);
			delete($<str>ID);
		}
/****************************************************************************/


/* VarDecl -> StructType ID */
/****************************************************************************/
		| StructType ID {
			try {
				table->addVar(*($<str>ID),*($<str>StructType));
				($<var>result) = const_cast<Var*>(&(table->findVar(*($<str>ID))));
			}
			catch (InvalidTypeNameException e){
				// Redeclaration of variable
				errorUndefStruct(yylineno,*($<str>StructType));
				exit(0);
			}
			catch (NameAlreadyExistsException e){
				// Redeclaration of variable
				errorDef(yylineno,*($<str>ID));
				exit(0);
			}
			const StructNode& structNode = table->findStruct(*($<str>StructType));
			for ( int i = 0 ; i < structNode.size() ; i++ ) {
				push(0);
			}
			delete($<str>StructType);
			delete($<str>ID);
		}
/****************************************************************************/
;

/* Type -> INT */
/****************************************************************************/
Type : INT {
			$<str>$ = $<str>INT;
			// #NoEmit
		}
/****************************************************************************/


/* Type -> BYTE */
/****************************************************************************/
		| BYTE {
			$<str>$ = $<str>BYTE;
			// #NoEmit
		}
/****************************************************************************/


/* Type -> BOOL */
/****************************************************************************/
		| BOOL {
			$<str>$ = $<str>BOOL;
			// #NoEmit
		}
/****************************************************************************/
;

/* StructType -> STRUCT ID */
/****************************************************************************/
StructType : STRUCT ID {
			$<str>StructType = $<str>ID;
			// #NoEmit
		}
/****************************************************************************/
;

/* Exp -> LPAREN Exp RPAREN */
/****************************************************************************/
Exp[result]	: LPAREN Exp[left] RPAREN {
			($<var>result) = ($<var>left);
			// #NoEmit
		}
/****************************************************************************/


/* Exp -> Exp MUL Exp */
/****************************************************************************/
		| Exp[left] MUL Exp[right] { 
			if (($<var>left->getType() != "int") && 
				($<var>left->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);	
			}
			if ((($<var>right)->getType() != "int") && 
				(($<var>right)->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);	
			}
			if (($<var>left->getType() == "int") || 
				($<var>right->getType() == "int")){
				$<var>result = new Var("__temp","int");
			}
			else {
				$<var>result = new Var("__temp","byte");
			}
			regPool->freeReg($<var>left->getReg());
			regPool->freeReg($<var>right->getReg());
			($<var>result)->allocReg(regPool->allocateReg());
			stringstream code;
			if ( *($<str>MUL) == string("*") ) {
				if ( $<var>result->getType() == "int" ) {
					code << "mul "; 
				}
				else {
					code << "mulo ";
				}
			}
			else { 
				if ( $<var>result->getType() == "int" ) {
					code << "div "; 
				}
				else {
					code << "divu ";
				}
			}
			code 
				<< "$" 
				<< $<var>result->getReg()
				<< ", $" 
				<< $<var>left->getReg()
				<< ", $" 
				<< $<var>right->getReg();
			emit(code.str());
			$<var>left->freeReg();
			$<var>right->freeReg();
			delete ($<str>MUL);
			if ($<var>left->getName() == "__temp"){
				delete ($<var>left);
			}
			if ($<var>right->getName() == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Exp -> Exp ADD Exp */
/****************************************************************************/
		| Exp[left] ADD Exp[right] {
			if (($<var>left->getType() != "int") && 
				($<var>left->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);	
			}
			if (($<var>right->getType() != "int") && 
				($<var>right->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);	
			}
			if (($<var>left->getType() == "int") || 
				($<var>right->getType() == "int")){
				$<var>result = new Var("__temp","int");
			}
			else {
				$<var>result = new Var("__temp","byte");
			}
			regPool->freeReg($<var>left->getReg());
			regPool->freeReg($<var>right->getReg());
			$<var>result->allocReg(regPool->allocateReg());
			stringstream code;
			if ( *($<str>ADD) == string("+") ) {
				if ( $<var>result->getType() == "int" ) {
					code << "add "; 
				}
				else {
					code << "addu ";
				}
			}
			else { 
				if ( $<var>result->getType() == "int" ) {
					code << "sub "; 
				}
				else {
					code << "subu ";
				}
			}
			code 
				<< "$" 
				<< ($<var>result)->getReg()
				<< ", $" 
				<< ($<var>left)->getReg()
				<< ", $" 
				<< ($<var>right)->getReg();
			emit(code.str());
			$<var>left->freeReg();
			$<var>right->freeReg();
			delete ($<str>ADD);
			if ($<var>left->getName() == "__temp"){
				delete ($<var>left);
			}
			if ($<var>right->getName() == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Exp -> ID */
/****************************************************************************/
		| ID {
			try {
				$<var>result = const_cast<Var*>(&(table->findVar(*($<str>ID))));
			}
			catch (VariableNotFoundException e){
				// Using undefined variable
				errorUndef(yylineno,*($<str>ID));
				exit(0);
			}
			try {
				table->findStruct($<var>result->getType());
			}
			catch (StructNotFoundException e){
				$<var>result->allocReg(regPool->allocateReg());
				emit(load($<var>result->getReg(), $<var>result->getPlace()));
				if ( $<var>result->getType() == "bool") {
					stringstream code;
					code 
						<< "beq $" 
						<< $<var>result->getReg()	
						<< ", $0" 
						<< ", ";
					$<var>result->falselist() = emitWithPatch(code.str());
					$<var>result->truelist() = emitWithPatch("j ");
					regPool->freeReg($<var>result->getReg());
					$<var>result->freeReg();
				}
			}
			delete ($<str>ID);
		}
/****************************************************************************/


/* Exp -> ID PERIOD ID */
/****************************************************************************/
		| ID[left] { 
		/********************************************************************/
			try{
				const string& structName =
					table->findVar(*($<str>left)).getType();
				table->findStruct(structName);
			}
			catch (VariableNotFoundException e){
				// Using undefined struct
				errorUndef(yylineno,*($<str>left));
				exit(0);
			}
			catch (StructNotFoundException e){
				// Using undefined struct
				errorUndef(yylineno,*($<str>left));
				exit(0);
			}
		/********************************************************************/
		} PERIOD ID[right] {
		/********************************************************************/
			const Var* var;
			const StructNode* strct;
			try{
				var = &(table->findVar(*($<str>left))); 
				strct = &(table->findStruct(var->getType()));
				$<var>result = const_cast<Var*>(&(strct->find(*($<str>right))));
			}
			catch (VariableNotFoundException e){
				// Using undefined struct member
				errorUndefStructMember(yylineno,*($<str>left));
				exit(0);
			}
			$<var>result->allocReg(regPool->allocateReg());
			emit(load(
				$<var>result->getReg(), 
				var->getPlace() + $<var>result->getPlace()));
			delete ($<str>left);
			delete ($<str>right);
		}
/****************************************************************************/


/* Exp -> Call */
/****************************************************************************/
		| Call {
			$<var>result = $<var>Call;
			if ( $<var>result->getType() == "bool") {
				stringstream code;
				code 
					<< "beq $" 
					<< $<var>result->getReg()	
					<< ", $0" 
					<< ", ";
				$<var>result->falselist() = emitWithPatch(code.str());
				$<var>result->truelist() = emitWithPatch("j ");
				regPool->freeReg($<var>result->getReg());
				$<var>result->freeReg();
			}
		}
/****************************************************************************/


/* Exp -> NUM */
/****************************************************************************/
		| NUM {
			$<var>result = new Var("__temp","int");
			$<var>result->allocReg(regPool->allocateReg());
			emit(loadi($<var>result->getReg(),$<num>NUM));
		}
/****************************************************************************/


/* Exp -> NUM B */
/****************************************************************************/
		| NUM B {
			if ($<num>NUM > 255){
				std::stringstream ss;
				ss << $<num>NUM;
				// Invalid value for byte
				errorByteTooLarge(yylineno,ss.str());
				exit(0);
			}
			$<var>result = new Var("__temp","byte");
			$<var>result->allocReg(regPool->allocateReg());
			emit(loadi($<var>result->getReg(),$<num>NUM));
		}
/****************************************************************************/


/* Exp -> STRING */
/****************************************************************************/
		| STRING {
			$<var>result = new Var("__temp","string");
			string strLabel = codeBuffer.genDataLabel();
			stringstream code;
			code << ".asciiz " << *($<str>STRING);
			codeBuffer.emitData(code.str());
			$<var>result->allocReg(regPool->allocateReg());
			code.str("");
			code << "la $" << $<var>result->getReg() << ", " << strLabel;
			emit(code.str());
			delete($<str>STRING);
		}
/****************************************************************************/


/* Exp -> TRUE */
/****************************************************************************/
		| TRUE {
			$<var>result = new Var("__temp","bool");
			$<var>result->truelist() = emitWithPatch("j ");
		}
/****************************************************************************/


/* Exp -> FALSE */
/****************************************************************************/
		| FALSE {
			$<var>result = new Var("__temp","bool");
			$<var>result->falselist() = emitWithPatch("j ");
		}
/****************************************************************************/


/* Exp -> NOT Exp */
/****************************************************************************/
		| NOT Exp[left] {
			const string& leftType = $<var>left->getType();
			const string& leftName = $<var>left->getName();
			if (leftType != "bool"){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			$<var>result = new Var("__temp","bool");
			$<var>result->truelist() = $<var>left->falselist();
			$<var>result->falselist() = $<var>left->truelist();
			if (leftName == "__temp"){
				delete ($<var>left);
			}
		}
/****************************************************************************/


/* Exp -> Exp AND Exp */
/****************************************************************************/
		| Exp[left] AND {
			$<str>$ = new string(genLabel());
		} Exp[right] { 
			if ($<var>left->getType() != "bool"){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			if ($<var>right->getType() != "bool"){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			($<var>result) = new Var("__temp","bool");	
			backpatch($<var>left->truelist(),*($<str>3));
			$<var>result->falselist() = merge(
				$<var>left->falselist(),
				$<var>right->falselist()
			);
			$<var>result->truelist() =$<var>right->truelist();
			delete ($<str>3);
			if ($<var>left->getName() == "__temp"){
				delete ($<var>left);
			}
			if ($<var>right->getName() == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Exp -> Exp OR Exp */
/****************************************************************************/
		| Exp[left] OR {
			$<str>$ = new string(genLabel());
		} Exp[right] {
			if ($<var>left->getType() != "bool"){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			if ($<var>right->getType() != "bool"){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			$<var>result = new Var("__temp","bool");	
			backpatch($<var>left->falselist(),*($<str>3));
			$<var>result->truelist() = merge(
				$<var>left->truelist(),
				$<var>right->truelist()
			);
			$<var>result->falselist() = $<var>right->falselist();
			delete ($<str>3);
			if ($<var>left->getName() == "__temp"){
				delete ($<var>left);
			}
			if ($<var>right->getName() == "__temp"){
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Exp -> Exp REL Exp */
/****************************************************************************/
		| Exp[left] REL Exp[right] {
			if (($<var>left->getType() != "int")&&
				($<var>left->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			if (($<var>right->getType() != "int")&&
				($<var>right->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			$<var>result = new Var("__temp","bool");
			regPool->freeReg(($<var>left)->getReg());
			regPool->freeReg(($<var>right)->getReg());
			stringstream code;
			if ( *($<str>REL) == string("<") ) {
				code << "blt";
			} else if ( *($<str>REL) == string("<=") ) {
				code << "ble";			
			} else if ( *($<str>REL) == string(">") ) {
				code << "bgt";			
			} else if ( *($<str>REL) == string(">=") ) {
				code << "bge";			
			}
			code
				<< " $" 
				<< $<var>left->getReg()	
				<< ", $" 
				<< $<var>right->getReg()
				<< ", ";

			$<var>result->truelist() = emitWithPatch(code.str());
			$<var>result->falselist() = emitWithPatch("j ");
			$<var>left->freeReg();
			$<var>right->freeReg();
			delete ($<str>REL);
			if ($<var>left->getName() == "__temp") {
				delete ($<var>left);
			}
			if ($<var>right->getName() == "__temp") {
				delete ($<var>right);
			}
		}
/****************************************************************************/


/* Exp -> Exp EQ Exp */
/****************************************************************************/
		| Exp[left] EQ Exp[right] {
			if (($<var>left->getType() != "int")&&
				($<var>left->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			if (($<var>right->getType() != "int")&&
				($<var>right->getType() != "byte")){
				// Mismatch of type for operation
				errorMismatch(yylineno);
				exit(0);
			}
			$<var>result = new Var("__temp","bool");
			regPool->freeReg($<var>left->getReg());
			regPool->freeReg($<var>right->getReg());
			stringstream code;
			if (*($<str>EQ) == "==") {
				code << "beq";
			}
			else {
				code << "bne";
			}
			code 
				<< " $" 
				<< $<var>left->getReg()	
				<< ", $" 
				<< $<var>right->getReg() 
				<< ", ";
			$<var>result->truelist() = emitWithPatch(code.str());
			$<var>result->falselist() = emitWithPatch("j ");
			$<var>left->freeReg();
			$<var>right->freeReg();
			delete ($<str>EQ);
			if ($<var>left->getName() == "__temp") {
				delete ($<var>left);
			}
			if ($<var>right->getName() == "__temp") {
				delete ($<var>right);
			}
		}
/****************************************************************************/
;

%%

int main() {
	yyparse();
	codeBuffer.printCodeBuffer();
	codeBuffer.printDataBuffer();
	return 0;
}

void yyerror(char const* s){
	errorSyn(yylineno);
	exit(0);
}

string genLabel() {
		return codeBuffer.genLabel();
}

int emit(string code) {
	return codeBuffer.emit(code);
}

vector<int> makelist(int i) {
	return CodeBuffer::makelist(i);
}

void backpatch(const std::vector<int>& address_list, const std::string &loc) {
	codeBuffer.bpatch(address_list,loc);
}

vector<int> emitWithPatch(string code) {
	return makelist(emit(code));
}

string loadi(int reg, int i) {
	stringstream code;
	code 
		<< "li $"
		<< reg
		<< ", "
		<< i;
	return code.str();
}

string load(int reg, int offset) {
	if (offset >= 0){
		offset +=4;
	}
	stringstream code;
	code 
		<< "lw $"
		<< reg
		<< ", "
		<< -offset
		<< "($fp)";
	return code.str();
}

string store(int reg, int offset) {
	if (offset >= 0){
		offset +=4;
	}
	stringstream code;
	code 
		<< "sw $"
		<< reg
		<< ", "
		<< -offset
		<< "($fp)";
	return code.str();
}

void pop(int reg) {
	stringstream code;
	emit("addi $sp,$sp,4");
	code 
		<< "lw $"
		<< reg
		<< ", 0($sp)";
	emit(code.str());
}

void rpop(int reg) {
	stringstream code;
	code 
		<< "lw $"
		<< reg
		<< ", 0($sp)";
	emit(code.str());
	emit("addi $sp, $sp, -4");
}

void push(int reg) {
	stringstream code;
	code 
		<< "sw $"
		<< reg
		<< ", 0($sp)";
	emit(code.str());
	emit("addi $sp, $sp, -4");
}

void rpush(int reg) {
	stringstream code;
	emit("addi $sp, $sp, 4");
	code 
		<< "sw $"
		<< reg
		<< ", 0($sp)";
	emit(code.str());
}

void emitPrint(){
	emit("print:");
	push(30); //backup $fp
	emit("addi $fp, $sp, 4");
	emit(loadi(2,4));
	emit(load(4,-4));
	emit("syscall");
	pop(30);
	emit("jr $ra");
}

void emitPrinti(){
	emit("printi:");
	push(30); //backup $fp
	emit("addi $fp, $sp, 4");
	emit(loadi(2,1));
	emit(load(4,-4));
	emit("syscall");
	pop(30);
	emit("jr $ra");
}

vector<int> merge(const vector<int> &l1,const vector<int> &l2) {
	return CodeBuffer::merge(l1,l2);
}

